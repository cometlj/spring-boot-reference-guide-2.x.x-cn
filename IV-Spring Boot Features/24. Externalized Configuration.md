# 24 外部配置

Spring Boot允许你通过外部化配置，来实现在不同环境中开发同一个应用程序你可以使用属性文件，YAML文件，环境变量和命令行参数来实现外部配置。可以通过Spring的环境抽象访问，将`@Value`注解直接注入属性值，或者通过`ConfigurationProperties`来[绑定到结构化对象上]()

Spring Boot使用一个特殊设计的`PropertySource`顺序，来接收属性值覆写。属性值会按照如下顺序：


1. home目录(devtools激活时候~/.spring-boot-devtools.properties)下的[Devtools的全局配置属性]()

2. 测试中的[@TestPropertySource]()注解.

3. 注解中的[@SpringBootTest#properties]()注解属性.

4. 命令行参数

5. `SPRING_APPLICATION_JSON`(嵌入在环境变量或系统属性中的内联JSON)中的属性
 
6. ServletConfig初始化参数.

7. ServletContext初始化参数.

8. `java:comp/env`下的JNDI属性.

9. Java系统属性 (`System.getProperties()`).

10. 系统环境变量.

11. 只存在于`random.*`的`RandomValuePropertySource`属性.

12. jar包之外的指定配置文件的应用属性(application-{profile}.properties和YAML变量)

13. jar包之内的指定配置文件的应用属性(application-{profile}.properties和YAML变量)

14. jar包之外的应用属性 (application.properties和YAML变量).

15. jar包之内的应用属性 (application.properties和YAML变量).

16. @Configuration类中的@PropertySource注解.

17. 默认属性(通过SpringApplication.setDefaultProperties指定).

为提供一个具体的例子，假设你开发了一个`@Component`组件并使用了`name`属性，样例代码如下所示：

```java
import org.springframework.stereotype.*
import org.springframework.beans.factory.annotation.*
@Component
public class MyBean { 
	@Value("${name}")
	private String name;
// ...
}
```

在你的应用classpath中(例如，在你的jar包中)你可以使用`application.properties`文件来提供`name`的默认值。当运行在一个新环境中时，jar包能够使用一个新的`application.properties`文件来覆写`name`值。对于一次性测试，你可以通过特定的命令行开关(例如`java -jar app.jar --name="Spring"`)来启动。

> **小贴士**
> 
> `SPRING_APPLICATION_JSON`属性集能够通过带有环境变量的命令行来提供使用。例如，你可以在UN*X shell中使用以下命令：
> 
> ```bash
> $ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar
> ```
> 
> 在之前的例子中，Spring环境中使用`acme.name=test`来结尾。你也可以通过使用`spring.application.json`作为系统属性传递，样例代码如下所示：
> 
> ```bash
> $ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar
> ```
> 
> 你也可以通过提供命令行参数JSON，样例代码如下所示：
> 
> ```bash
> $ java -jar myapp.jar --spring.application.json='{"name":"test"}'
> ```
> 
> 你可以提供JSON和JNDI变量，例如：`java:comp/env/spring.application.json`


## 24.1 配置随机值

`RandomValuePropertySource`对注入随机值非常实用(例如，秘钥或测试用例)。它能生成Integer整型，Long类型，uuid或者字符串，样例代码如下所示：

```java
my.secret=${random.value} 
my.number=${random.int} 
my.bignumber=${random.long} 
my.uuid=${random.uuid} 
my.number.less.than.ten=${random.int(10)} 
my.number.in.range=${random.int[1024,65536]}
```

The random.int* syntax is OPEN value (,max) CLOSE where the OPEN,CLOSE are any character and value,max are integers. If max is provided, then value is the minimum value and max is the maximum value (exclusive).

`random.int*`语法是一个区间值(,max),OPEN,CLOSE可以是任何值，`max`是整型值。如果给定`max`的值，则`value`是最小值而`max`是最大值(不包含)

## 24.2 获取命令行参数值

默认情况下，`SpringApplication`会转换任何命令行选项参数(意味着，以`--`开头的参数，例如`--server,port=9000`)为属性值，并且添加进Spring环境中。如前所述，命令行属性总是优先于其他属性源。

如果你不希望将命令行属性值添加进环境变量中，你可以通过使用`SpringApplication.setAddCommandLineProperties(false)`来禁用它。

## 24.3 应用属性文件

`SpringApplication`会从以下位置的`application.properties`文件中加载属性值到Spring环境中：

1. 当前目录的`/config`子目录
2. 当前目录
3. classpath下的`/config`包
4. classpath根目录

> 自己添加：优先级顺序**由低到高**

列表是按照优先级顺序加载的(定义在更改列表优先级的属性会覆盖优先级较低的属性)

> **注意**
> 
> 你也可以[使用 YAML(.yml)文件]()来替换'.properties'文件

如果你不喜欢使用`application.properties`作为你的配置文件名，你可以通过指定`spring.config.name`环境属性来改变配置文件的名字。你也可以使用`spring.config.name`环境属性明确指定属性文件的地址(目录位置或者文件路径使用逗号分隔)。下面代码展示了如何指定一个不同的配置文件的例子：

```bash
$ java -jar myproject.jar --spring.config.name=myproject
```

下面的例子展示了如何指定2个位置：

```bash
 $ java -jar myproject.jar --spring.config.location=classpath:default.properties,classpath:/
override.properties
```

> **警告**
> 
> `spring.config.name`和`spring.config.location`可以用来在早期决定加载哪个文件，所以他们必须要被定义为一个环境属性(通常就是系统环境变量，系统属性，或者命令行参数)。

如果`spring.config.location`包含了目录(相对于文件来说)，那么必须要以`/`结尾(而且，在运行时，要在加载前从`spring.config.name`添加上生成的名称，包括指定配置文件的名字)。在`spring.config.location`中指定的文件按原样使用，不支持指定配置文件变量，而且将会被任何指定配置文件的属性覆盖。

配置路径会以相反的顺序搜索。默认情况下，配置的路径地址为：`classpath:/,classpath:/config/,file:./,file:./config/`。由此产生的搜索顺序如下：

1. file:./config/
2. file:./
3. classpath:/config/
4. classpath:/

当使用`spring.config.location`做自定义配置的时候，会覆盖掉默认的路径。例如，如果使用`classpath:/custom-config/,file:./custom-config/`来指定`spring.config.location`，搜索顺序会变为如下所示：

1. file:./custom-config/

2. classpath:custom-config/

另外，当使用`spring.config.additional-location`来定义配置文件地址时，除了默认地址外也会使用这些地址。额外地址会在默认地址之前被搜索到。例如，如果配置了额外地址为：`classpath:/custom- config/,file:./custom-config/`，那么搜索顺序会变为：

1. file:./custom-config/

2. classpath:custom-config/ 3. file:./config/

3. file:./

4. classpath:/config/

5. classpath:/

此搜索顺序允许在一个配置文件中指定默认值，然后有选择地覆盖另一个配置文件中的值。你可以在你的应用程序提供`application.properties`默认值（或任何你选择的`spring.config.name`的其他文件名）在一个默认的位置。然后，这些默认值可以在运行时被一个自定义位置的不同文件覆盖。

> **注意**
> 
> 如果你更愿意使用系统属性而不是环境变量，大多数操作系统不允许句号分隔的关键字，但你可以用下划线代替（例如，`SPRING_CONFIG_NAME`代替`spring.config.name`）。

> **注意**
> 
> 如果你的应用是在容器中运行，那么JNDI属性(在`java:comp/env`中)或servlet上下文初始化参数会替代环境变量或系统属性。

## 24.4 特定的Profile属性

除了`application.properties`文件外，特定的profile属性也可以通过使用如下的命名约定来定义：`application-{profile}.properties`。`Environment`有一系列默认配置文件(默认为[default])，如果没有使用激活的配置文件，会使用默认的配置文件。也就是说，如果没有明确激活配置文件，那么会加载`application-default.properties`配置文件的属性值。

特定的profile属性会从相同位置加载`application.properties`，特定的profile文件总是覆盖非特定的配置文件，无论特定profile文件在你打包的jar内部还是外部。

如果指定了几个配置文件，将会应用最后一个。例如，`spring.profiles.active`属性指定的配置文件在那些配置的文件之后通过`SpringApplication` API添加，因此优先级更高。

> **注意**
> 
> 如果你在`spring.config.location`中指定了任何文件，那么特定文件的特定profile文件将不会被考虑。如果你也想使用特定的profile属性，请在`spring.config.location`中指定profile的目录。 --not good








































