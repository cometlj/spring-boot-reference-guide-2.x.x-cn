# 27. 开发Web应用

Spring Boot非常适合用于Web应用开发。你可以通过内置的Tomcat，Jetty,Undertow或者Netty创建一个独立的的HTTP服务器。大部分web应用可以使用`spring-boot-starter-web`模块作为入手，而且运行非常快速。你可以使用`spring-boot-starter-webflux`模块来编译响应式web应用。

如果还没有开发过Spring Boot的web应用项目，可以在[Getting started]()查看"Hello World"项目。

## 27.1 Spring Web MVC框架

[Spring Web MVC框架](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)(经常被简称为“Spring MVC”)是一个内容丰富的“模型-视图-控制器”web框架。Spring MVC能够让你创建特殊的`@Controller`和`@RestController`bean类来接收HTTP请求。控制器中的方法能够通过`@RequestMapping`注解映射到HTTP请求上。

以下的代码展示了典型的处理JSON数据的`@RestController`：

```java
@RestController
@RequestMapping(value="/users")
public class MyRestController {

	@RequestMapping(value="/{user}", method=RequestMethod.GET)
	public User getUser(@PathVariable Long user) {
		// ...
	}

	@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
	List<Customer> getUserCustomers(@PathVariable Long user) {
		// ...
	}

	@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
	public User deleteUser(@PathVariable Long user) {
		// ...
	}

}
```
Spring MVC是Spring框架中的核心部分，详细内容请见[参考文档](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)。这里[spring.io/guides](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)有一些Spring MVC的可用指导内容。

### 27.1.1 Spring MVC自动配置

Spring Boot提供了适用于大多数应用的Spring MVC自动配置功能。

自动配置在Spring默认配置上层添加了以下特性：

- 包含了`ContentNegotiatingViewResolver`和`BeanNameViewResolver`beans类。
- 静态资源的服务支持，包括WebJars支持([27.1.5 Static Content]())
- `Converter`,`GenericConverter`和`Formatter`beans的自动注册
- `HttpMessageConverters`支持[27.1.2 HttpMessageConverters]()
- `MessageCodesResolver`支持[27.1.4 MessageCodesResolver]()
- 静态`index.html`支持
- 自定义`Favicon`支持[27.1.7 Custom Favicon]()
- `ConfigurableWebBindingInitializer`bean类的自动使用[27.1.9 ConfigurableWebBindingInitializer]()

如果你想保持Spring Boot MVC功能并且希望添加[MVC配置](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)(拦截器，类型转换器，视图控制器，以及其他功能)，可以添加类型为`WebMvcConfigurer`的`@Configuration`类，但是不能使用`@EnableWebMvc`注解。如果你希望提供`RequestMappingHandlerMapping`,`RequestMappingHandlerAdapter`或者`ExceptionHandler`,`ExceptionResolver`的自定义实例，可以通过声明`WebMvcRegistrationsAdapter`实例来提供这些组件。

如果你希望获得Spring MVC的所有控制权，可以使用`@EnableWebMvc`和`@Configuration`注解在一起使用。

### 27.1.2 HttpMessageConverters

Spring MVC使用`HttpMessageConverter`接口来转换HTTP请求和响应。Sensible defaults are included out of the box(默认设置是开箱可用的)。例如，对象能够自动转换为JSON对象(通过Jackson库)或XML(如果可用的话，可使用Jackson XML扩展，或在该扩展不可用情况下使用JAXB)。默认状态下，字符串会被编码为`UTF-8`。

如果你希望添加或自定义实现转换器，可以使用Spring Boot的`HttpMessageConverters`类，例如如下代码：

```java
import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration
public class MyConfiguration {

	@Bean
	public HttpMessageConverters customConverters() {
		HttpMessageConverter<?> additional = ...
		HttpMessageConverter<?> another = ...
		return new HttpMessageConverters(additional, another);
	}

}
```

任何存在context上下文的`HttpMessageConverter`bean类都会被添加在转换器列表中。你也可以使用同样方法来覆写默认转换器。

### 27.1.3 自定义JSON序列化和反序列化

如果你使用Jackson来序列化和反序列化JSON数据，也许会想要编写自己的`JsonSerializer`和`JsonDeserializer`类。自定义的序列化类通常使用[通过模块使用Jackson注册](http://wiki.fasterxml.com/JacksonHowToCustomDeserializers)，但Spring Boot提供了另外一种方式`@JsonComponent`来更容易的直接注册为Spring Beans.

你可以直接在`JsonSerializer`和`JsonDeserializer`实现类中使用`@JsonComponent`注解。也可以在包含了序列化/反序列化的内部类中使用，例如：

```java
import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

	public static class Serializer extends JsonSerializer<SomeObject> {
		// ...
	}

	public static class Deserializer extends JsonDeserializer<SomeObject> {
		// ...
	}

}
```

所有在`ApplicationContext`上下文中的`@JsonComponent`beans类都会自动注册Jackson。因为`@JsonComponent`是使用`@Component`元注释的，常用的组件扫描规则均适用。

在序列化对象时，Spring Boot也提供了`JsonObjectSerializer`和`JsonObjectDeserializer`基类来提供有用的不同Jackson版本实现。详情请查阅[JsonObjectSerializer](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html)和[JsonObjectDeserializer](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html)

### 27.1.4 MessageCodesResolver

Spring MVC有一个生成错误代码的策略，用于从绑定错误:`MessageCodesResolver`中呈现错误消息。如果设置了`spring.mvc.message-codes-resolver.format`属性`PREFIX_ERROR_CODE`或`POSTFIX_ERROR_CODE`,Spring Boot会为你生成一份(请查阅[DefaultMessageCodesResolver.Format](https://docs.spring.io/spring/docs/5.0.4.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html)的枚举值)

### 27.1.5 静态内容

默认情况下，Spring Boot从类路径或者`ServletContext`根目录中的`/static`(或`/public`，`/resources`,`META-INFO/resources`)文件夹中读取静态内容。它使用Spring MVC的`ResourceHttpRequestHandler`类，所以你能够通过添加自定义`WebMvcConfigurer`类和覆写`addResourcesHandlers`方法来修改其行为。

在独立的web应用中，容器中默认的servlet也被启用并充当回退的角色，如果Spring决定不去处理servlet的时候会从`ServletContext`根中获取内容。不过这大多数时候是不会发生的(除非你修改了默认的MVC配置),因为Spring总能够通过`DispatcherServlet`中处理请求。

默认情况下，资源文件会被映射为`/**`，但你可以通过`spring.mvc.static-path-pattern`属性来调整值。例如，将所有资源重新分配给`/resources/**`实现样例如下：

```bash
spring.mvc.static-path-pattern=/resources/**
``` 

你可以通过设置`spring.resources.static-locations`属性来自定义资源路径(可使用目录位置列表替换默认值)。根servlet上下文路径，`/`，也会自动添加为路径。

除了前面提到的“标准”静态资源位置之外，还对一个特殊情况[Webjars内容](http://www.webjars.org/)进行了说明。如果以Webjars格式打包，任何包含了`/webjars/**`路径的资源，将会从jar文件中获取。

> **小贴士**
> 
> 如果你开发的应用是以jar形式打包的，请不要使用`src/main/webapp`目录。虽然该目录是一个通用的标准目录，但它是仅为war包打包使用的，并且会在你生成jar包的时候被大多数打包工具忽略。

Spring Boot也支持由Spring MVC提供的高级资源处理功能，例如缓存破坏静态资源或者Webjars的不可预知URL地址。

为使用不可预知的Webjar地址，需要添加`webjars-locator-core`依赖。然后声明Webjar。例如以jQuery作为样例，添加`/webjars/jquery/dist/jquery.min.js`会生成`/webjars/jquery/x.y.z/dist/jquery.min.js`。其中`x.y.z`为Webjar版本。

> **注意**
> 
> 如果你使用了JBoss，你需要声明`webjars-locator-jboss-vfs`依赖来替换`webjars-locator-core`。否则，所有的Webjars会被解析为404错误。

要使用缓存清理功能，下面的配置项展示了为所有静态资源进行缓存清理的解决方案，会有效的添加一个内容hash值，例如在URL地址中，`<link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>`

```bash
spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
```

> **注意**
> 
> 因为Thymeleaf和FreeMarker中会自动配置`ResourceUrlEncodingFilter`拦截器，运行时的模板中资源链接会被覆写。你应该在使用JSP时手工声明这个拦截器。其他模板引擎目前暂时不支持自动配置，但是可以自定义模板宏/助手，和使用`ResourceUrlProvider`。

当加载器加载动态资源时，例如使用Javascript模块，重命名文件不是可选项。这就是为什么其他的机制可以被支持并能够被合并使用。这种“固定”策略通过在URL中添加静态版本字符串，而不是更改文件名，例如：

```xml
spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** spring.resources.chain.strategy.fixed.enabled=true spring.resources.chain.strategy.fixed.paths=/js/lib/ spring.resources.chain.strategy.fixed.version=v12
```

通过这个配置，Javascript在定位在"/js/lib/"下的内容，会使用一个固定的版本机制处理("v12/js/lib/mymodule.js")，其他资源仍然使用内容一(<link href="/ css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>)

查看[ResourceProperties](https://github.com/spring-projects/spring-boot/tree/v2.0.0.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java)获取更多支持的可选项

> **小贴士**
> 
> 这个功能在[这篇文章](https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources)中有着非常完整详尽的叙述，或者可以具体查阅Spring Framework的[参考文档](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources)

### 27.1.6 欢迎页面

Spring Boot支持静态化和模板化的欢迎页面。它会优先寻找配置了存放静态内容的`index.html`文件，然后会寻找`index`模板。无论哪一个被找到，就会自动被当做应用的欢迎页使用。

### 27.1.7 自定义网站图标Favicon

Spring Boot会在配置了存放静态内容的地方和类路径的根目录(以这个顺序)寻找`favicon.ico`。如果找到该文件存在，则会自动作为应用的favicon图标。

### 27.1.8 路径匹配和内容协商

Spring MVC可以通过查看请求路径将匹配的HTTP请求映射到处理程序，并将其匹配到应用程序中定义的映射。(例如，控制器方法中的`@GetMapping`注解)。

Spring Bug选择默认禁用后缀模式匹配，也就是说类似`GET /projects/spring-boot.json`这样的请求不会被匹配到`@GetMapping("/projects/spring-boot")`映射。这被认为是[Spring MVC应用的最好实践](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match)。这一特性过去主要用于HTTP客户端，而HTTP客户端没有发送正确的“Accept”请求报头；我们需要确保向客户端发送正确的内容类型。如今，内容协商更加可靠。

还有其他处理HTTP客户端的方法，这些客户端不总是发送正确的“Accept”请求报头。替代使用后缀匹配，我们可以使用查询参数来确保类似`GET /projects/spring-boot?format=json`的请求会被映射到`@GetMapping("/projects/spring-boot")`。

```xml
spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown
```

如果您理解这些注意事项，并且仍然希望应用程序使用后缀模式匹配，则需要以下配置：

```xml
spring.mvc.contentnegotiation.favor-path-extension=true

# You can also restrict that feature to known extensions only
# spring.mvc.pathmatch.use-registered-suffix-pattern=true

# We can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc
```

### 27.1.9 ConfigurableWebBindingInitializer

Spring MVC使用`WebBindingInitializer`来初始化`WebDataBinder`来对应特别的请求。如果你创建了`ConfigurableWebBindingInitializer @Bean`，Spring Boot会自动配置Spring MVC来使用它。

### 27.1.10 模板引擎

和REST web services一样，你也可以使用Spring MVC来处理动态HTML内容。Spring MVC支持多种模板技术，包括Thymeleaf,FreeMarker，以及JSP。同样，很多其他的模板引擎也包含他们自己的Spring MVC集成。

Spring Boot包含以下模板引擎的自动配置：

- [FreeMarker](https://freemarker.org/docs/)
- [Groovy](http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine)
- [Thymeleaf](http://www.thymeleaf.org/)
- [Mustache](https://mustache.github.io/)

> **小贴士**
> 
> 如果可能，应该尽量避免使用JSP。这里有当与内置的servlet容器使用时的一些[已知的限制](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations)

当你按照默认配置使用其中的一个模板引擎时，应用会自动从`src/main/resources/templates`目录下抓取模板页面。

> **小贴士**
> 
> 取决于你如何运行自己的程序，IntelliJ IDEA对类路径的排序不同。在IDE中从主方法运行应用程序会导致与使用Maven或Gradle或从其打包的jar运行应用程序时不同的排序。这可能导致Spring引导无法找到类路径上的模板。如果你有这个问题，你可以重新排序IDE中的类路径，以先放置模块的类和资源。或者说，你可以配置模板的前缀符在类路径中来搜索每个`templates`目录，例如：`classpath*:/templates/`。

### 27.1.11 错误处理

默认清苦下，Spring Boot会提供一个`/error`映射来明确的处理所有错误，并且以"全局"错误页面的形式注册在Servlet容器中。对于开发者客户端，会生成一个带有错误详细信息，HTTP状态和异常信息的JSON响应。对于网页浏览器客户端，会产生一个“白名单”错误视图，以HTML格式化的展现相同的数据(如果要自定义展示，需要添加一个View视图来解析错误信息)。要想完全替换掉默认的配置，您可以实现`ErrorController`并注册该类型的bean定义，或者添加`ErrorAttributes`类型的bean来使用现有的机制，但需要替换内容。












































