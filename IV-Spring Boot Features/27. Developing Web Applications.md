# 27. 开发Web应用

Spring Boot非常适合用于Web应用开发。你可以通过内置的Tomcat，Jetty,Undertow或者Netty创建一个独立的的HTTP服务器。大部分web应用可以使用`spring-boot-starter-web`模块作为入手，而且运行非常快速。你可以使用`spring-boot-starter-webflux`模块来编译响应式web应用。

如果还没有开发过Spring Boot的web应用项目，可以在[Getting started]()查看"Hello World"项目。

## 27.1 Spring Web MVC框架

[Spring Web MVC框架](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)(经常被简称为“Spring MVC”)是一个内容丰富的“模型-视图-控制器”web框架。Spring MVC能够让你创建特殊的`@Controller`和`@RestController`bean类来接收HTTP请求。控制器中的方法能够通过`@RequestMapping`注解映射到HTTP请求上。

以下的代码展示了典型的处理JSON数据的`@RestController`：

```java
@RestController
@RequestMapping(value="/users")
public class MyRestController {

	@RequestMapping(value="/{user}", method=RequestMethod.GET)
	public User getUser(@PathVariable Long user) {
		// ...
	}

	@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
	List<Customer> getUserCustomers(@PathVariable Long user) {
		// ...
	}

	@RequestMapping(value="/{user}", method=RequestMethod.DELETE)
	public User deleteUser(@PathVariable Long user) {
		// ...
	}

}
```
Spring MVC是Spring框架中的核心部分，详细内容请见[参考文档](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)。这里[spring.io/guides](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)有一些Spring MVC的可用指导内容。

### 27.1.1 Spring MVC自动配置

Spring Boot提供了适用于大多数应用的Spring MVC自动配置功能。

自动配置在Spring默认配置上层添加了以下特性：

- 包含了`ContentNegotiatingViewResolver`和`BeanNameViewResolver`beans类。
- 静态资源的服务支持，包括WebJars支持([27.1.5 Static Content]())
- `Converter`,`GenericConverter`和`Formatter`beans的自动注册
- `HttpMessageConverters`支持[27.1.2 HttpMessageConverters]()
- `MessageCodesResolver`支持[27.1.4 MessageCodesResolver]()
- 静态`index.html`支持
- 自定义`Favicon`支持[27.1.7 Custom Favicon]()
- `ConfigurableWebBindingInitializer`bean类的自动使用[27.1.9 ConfigurableWebBindingInitializer]()

如果你想保持Spring Boot MVC功能并且希望添加[MVC配置](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#mvc)(拦截器，类型转换器，视图控制器，以及其他功能)，可以添加类型为`WebMvcConfigurer`的`@Configuration`类，但是不能使用`@EnableWebMvc`注解。如果你希望提供`RequestMappingHandlerMapping`,`RequestMappingHandlerAdapter`或者`ExceptionHandler`,`ExceptionResolver`的自定义实例，可以通过声明`WebMvcRegistrationsAdapter`实例来提供这些组件。

如果你希望获得Spring MVC的所有控制权，可以使用`@EnableWebMvc`和`@Configuration`注解在一起使用。

### 27.1.2 HttpMessageConverters

Spring MVC使用`HttpMessageConverter`接口来转换HTTP请求和响应。Sensible defaults are included out of the box(默认设置是开箱可用的)。例如，对象能够自动转换为JSON对象(通过Jackson库)或XML(如果可用的话，可使用Jackson XML扩展，或在该扩展不可用情况下使用JAXB)。默认状态下，字符串会被编码为`UTF-8`。

如果你希望添加或自定义实现转换器，可以使用Spring Boot的`HttpMessageConverters`类，例如如下代码：

```java
import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration
public class MyConfiguration {

	@Bean
	public HttpMessageConverters customConverters() {
		HttpMessageConverter<?> additional = ...
		HttpMessageConverter<?> another = ...
		return new HttpMessageConverters(additional, another);
	}

}
```

任何存在context上下文的`HttpMessageConverter`bean类都会被添加在转换器列表中。你也可以使用同样方法来覆写默认转换器。

### 27.1.3 自定义JSON序列化和反序列化

如果你使用Jackson来序列化和反序列化JSON数据，也许会想要编写自己的`JsonSerializer`和`JsonDeserializer`类。自定义的序列化类通常使用[通过模块使用Jackson注册](http://wiki.fasterxml.com/JacksonHowToCustomDeserializers)，但Spring Boot提供了另外一种方式`@JsonComponent`来更容易的直接注册为Spring Beans.

你可以直接在`JsonSerializer`和`JsonDeserializer`实现类中使用`@JsonComponent`注解。也可以在包含了序列化/反序列化的内部类中使用，例如：

```java
import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

	public static class Serializer extends JsonSerializer<SomeObject> {
		// ...
	}

	public static class Deserializer extends JsonDeserializer<SomeObject> {
		// ...
	}

}
```

所有在`ApplicationContext`上下文中的`@JsonComponent`beans类都会自动注册Jackson。因为`@JsonComponent`是使用`@Component`元注释的，常用的组件扫描规则均适用。

在序列化对象时，Spring Boot也提供了`JsonObjectSerializer`和`JsonObjectDeserializer`基类来提供有用的不同Jackson版本实现。详情请查阅[JsonObjectSerializer](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html)和[JsonObjectDeserializer](https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html)

### 27.1.4 MessageCodesResolver

Spring MVC有一个生成错误代码的策略，用于从绑定错误:`MessageCodesResolver`中呈现错误消息。如果设置了`spring.mvc.message-codes-resolver.format`属性`PREFIX_ERROR_CODE`或`POSTFIX_ERROR_CODE`,Spring Boot会为你生成一份(请查阅[DefaultMessageCodesResolver.Format](https://docs.spring.io/spring/docs/5.0.4.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html)的枚举值)

### 27.1.5 静态内容

默认情况下，Spring Boot从类路径或者`ServletContext`根目录中的`/static`(或`/public`，`/resources`,`META-INFO/resources`)文件夹中读取静态内容。它使用Spring MVC的`ResourceHttpRequestHandler`类，所以你能够通过添加自定义`WebMvcConfigurer`类和覆写`addResourcesHandlers`方法来修改其行为。

在独立的web应用中，容器中默认的servlet也被启用并充当回退的角色，如果Spring决定不去处理servlet的时候会从`ServletContext`根中获取内容。不过这大多数时候是不会发生的(除非你修改了默认的MVC配置),因为Spring总能够通过`DispatcherServlet`中处理请求。

默认情况下，资源文件会被映射为`/**`，但你可以通过`spring.mvc.static-path-pattern`属性来调整值。例如，将所有资源重新分配给`/resources/**`实现样例如下：

```bash
spring.mvc.static-path-pattern=/resources/**
``` 

你可以通过设置`spring.resources.static-locations`属性来自定义资源路径(可使用目录位置列表替换默认值)。根servlet上下文路径，`/`，也会自动添加为路径。

除了前面提到的“标准”静态资源位置之外，还对一个特殊情况[Webjars内容](http://www.webjars.org/)进行了说明。如果以Webjars格式打包，任何包含了`/webjars/**`路径的资源，将会从jar文件中获取。

> **小贴士**
> 
> 如果你开发的应用是以jar形式打包的，请不要使用`src/main/webapp`目录。虽然该目录是一个通用的标准目录，但它是仅为war包打包使用的，并且会在你生成jar包的时候被大多数打包工具忽略。

Spring Boot也支持由Spring MVC提供的高级资源处理功能，例如缓存破坏静态资源或者Webjars的不可预知URL地址。

为使用不可预知的Webjar地址，需要添加`webjars-locator-core`依赖。然后声明Webjar。例如以jQuery作为样例，添加`/webjars/jquery/dist/jquery.min.js`会生成`/webjars/jquery/x.y.z/dist/jquery.min.js`。其中`x.y.z`为Webjar版本。

> **注意**
> 
> 如果你使用了JBoss，你需要声明`webjars-locator-jboss-vfs`依赖来替换`webjars-locator-core`。否则，所有的Webjars会被解析为404错误。






























































