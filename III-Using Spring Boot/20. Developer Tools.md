# 20. 开发者工具

Spring Boot包含了一个额外的工具集，能让你的应用开发体验更方便一些。`spring-boot-devtools`模块能够包含进任何项目中，来提供额外的开发阶段特性。如果需要添加devtools支持，需要将相关的模块依赖加入构建系统中，Maven和Gradle的样例代码如下：

**Maven**

```xml
<dependencies>
 <dependency>
    <groupId>org.springframework.boot</groupId> 
    <artifactId>spring-boot-devtools</artifactId> 
    <optional>true</optional>
 </dependency>
</dependencies>
```

**Gradle**

```xml
dependencies { 
 compile("org.springframework.boot:spring-boot-devtools")
}
```

> **注意**  
> 当运行一个完全打包的程序时，开发者工具会自动关闭。如果你的应用是通过`java -jar`命令或通过特定的类加载器启动的，那该项目会被认为是“产品级应用”。将依赖标记为optional是阻止开发工具间接影响到使用你应用的其它模块的最佳实践。Gradle不支持optional依赖开箱即用，同时你可能想看看[propdeps-plugin](https://github.com/spring-projects/gradle-plugins/tree/master/propdeps-plugin)
>
> **小贴士**  
> 重新打包的项目文件默认是不包含devtools的。如果你希望使用[某些远程devtools特性]()，必须要设置`excludeDevtools`构建属性为关闭来包含它（devtools）。Maven和Gradle插件均支持该属性。

## 20.1 默认属性

Spring Boot支持的某些库使用了缓存来提升性能。例如，[template engines]()缓存编译模板来避免重复的解析模板文件。还有Spring MVC在处理静态资源时，能够通过添加HTTP缓存Header头来进行响应。

然而缓存对生产环境使用非常有好处，但对于开发阶段会阻止你看到修改的变化。因为这个原因，spring-boot-devtools默认关闭了缓存选项。

缓存选项通常在`application.properties`文件中进行配置。例如,Thymeleaf提供了`spring.thymeleaf.cache`属性。不需要手动设置这些属性，`spring-boot-devtools`模块会自动提供灵敏的开发阶段配置。

> **小贴士**
> 
> 需要了解devtools的完整属性列表，请查阅[DevToolsPropertyDefaultPostProcessor](https://github.com/spring-projects/spring-boot/tree/v2.0.0.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java)

## 20.2 自动重启

当classpath中的文件发生变化时，使用`spring-boot-devtools`插件的应用就会自动重启。当使用IDE进行开发时，这是一个很有用的特性，因为当代码改变时会给你很快的反馈。默认情况下，它会监控所有classpath指向的文件内所有文件的变化。注意某些资源文件，例如静态资源和视图模板，不需要重启应用。

> **触发重启**
> 
> 当DevTools监控classpath的资源时，唯一能触发重启操作的就是更新classpath。
更新classpath的方式取决于你在使用的IDE。在Eclipse中，保存修改后的文件会对
classpath的更新操作继而触发重启。在IntelliJ IDEA中，编译项目(Build->Make Project)会有同样的效果。

------

> **注意**
> 
> 一旦启用了分支，你也可以通过使用被支持的编译插件(Maven和Gradle)来启动项目，因为DevTools需要一个独立的类加载器来正确操作。默认情况下，Gradle和Maven检测DevTools如果在classpath类路径中就会执行启动操作。

> **小贴士**
> 
> 当使用LiveReload的时候，自动重启会运行的非常好。[查阅See the LiveRelaod章节]()。如果你使用了JRebel，自动重启会关闭以有利于动态类的重加载。devtools的其他特性(例如LiveReload和属性覆写)仍然能够使用。

> **注意**
> 
> 在重启期间，DevlTools依赖应用程序上下文的关闭钩子来关闭自身。如果你禁用了关闭钩子(SpringApplication.setRegisterShutDownHook(false))，DevTools将会工作不正常。

> **注意**
> 
> 当决定classpath中的输入引起的改变是否应该触发重启时，DevTools会自动忽略命名为spring-boot，spring-boot-devtools，spring-boot-autoconfigure，spring-boot-actuator和spring-boot-starter的项目内容。

> **注意**
> DevTools需要使用`ApplicationContext`来自定义`ResourceLoader`。如果应用中已经提供了一个实现，另一个将被内置进来。不支持直接覆写`ApplicationContext`中的`getResource`方法。

------

> **重启和重新加载**
> 
> Spring Boot的重启技术是通过2个类加载器工作的。不会变化的类(例如，第三方jar包中的类)被加载进入一个基类加载器。开发中的类会被加载进入重启加载器。当应用重启时，重启加载器会被注销并重新建立一个新的。这种方式意味着应用的重启比起“冷启动”来言会更快，因为基类加载器已经生成并出于可用状态了。
> 
> 如果你发现重启速度不是那么快速或者遇到了类加载的问题，你需要考虑例如来自ZeroTurnaround的JRebel重新加载技术。该技术通过加载时类的重写使它们更适合重载。

### 条件评估中的日志变更 --not good

默认情况下，每次你的应用发生重启，项目的条件评估报告就会被记录下来。这份报告会展示当你的自动配置发生变化时，例如添加或者删除了某些bean文件和设置了配置属性时的情况。

如果要关闭该报告记录功能，设置如下属性即可：

> spring.devtools.restart.log-condition-evaluation-data=false

### 排除资源文件

当某些资源文件发生变化时没有必要触发重启操作。例如，Thymeleaf模板能够直接编辑。默认情况下，修改`/META-INF/maven`，`/META-INF/resources`，`/resources`，`/static`，，`/public`或者`/template`文件夹下的内容不会触发重启操作但会触发一个[实时重载]()。如果你希望是自定义这些排除项，可以对`spring.devtools.restart.exclude`进行配置。例如，想要排除`/static`和`/public`文件夹下的内容，就可以这样而配置：

> spring.devltools.restart.exclude=statis/** ,public/**

> **小贴士**
> 
> 如果你希望保留默认的设置并且添加新的排除项，可以对`spring.devtools.restart.additional-exclude`属性进行配置。

### 监控其他路径

当你修改不在classpath下的文件，你可能也希望也能够自动重启和重新加载。为达到目的，你可以修改`spring.devtools.restart.additional-paths`属性来配置需要监控变化的其他路径。通过使用前面描述的`spring.devtools.restart.exclude`属性来控制其它路径上的变化是否会触发重启或仅触发实时重载。

### 禁用重启

如果你不希望使用重启特性，可以通过设置`spring.devtools.restart.enabled`属性来禁用它。在大多数情况下，你可以在`application.properties`中设置该属性(这样仍然会初始化重启类加载器但它不会监控文件的变化)

如果你需要完全禁用重启支持(例如，它不能和特定的库一同运行)，你需要在`SpringApplication.run(...)`方法前设置一个`System`属性，其中`spring.devtools.restart.enabled`为`fasle`，样例代码如下：

```java
public static void main(String[] args) { 
	System.setProperty("spring.devtools.restart.enabled", "false");
	SpringApplication.run(MyApp.class, args);
}
```

### 使用触发器文件

如果你的IDE不停的编译修改文件，你可能更愿意在特定时候触发重启操作。为达到目的，你可以使用一个"触发器文件"，当你想要触发一个重启检查时必须修改该文件。修改该文件只会触发重启检查，只有DevTools检测到文件内需要做什么操作时候才会触发重启操作。触发器文件能够通过手动方式或者IDE插件进行更新。

要想使用触发器文件，需要设置`spring.devtools.restart.trigger-file`属性指定触发器文件。

> **小贴士**
> 
> 如果你希望所有项目均可使用该触发器文件，必须要设置`spring.devtools.restart.trigger-file`为[全局配置]()

### 自定义重启类加载器

在上面提到的[重启和重新加载]()章节中，重启功能是通过2个类加载器实现的。对于大多数应用来说，这种方式很有效。但是，有时会导致类加载的问题。

默认情况下，任何IDE中打开的项目都会通过“重启”类加载器加载，任何规范的`.jar`文件会被“基类”加载器加载。如果你运行的是一个多模块项目，并且不是所有的模块都被导入到你的IDE中，你可能需要自定义某些配置。为了实现这个目的，你可以创建一个`META-INF/spring-devtools.properties`文件。

`spring-devtools.properties`文件`能够包含前缀为`restart.exclude`和`restart.include`的属性。`include`元素应该被加入到“restart”类加载器中，而`exclude`元素应该被加入到“base”类加载器中。对应的value值是通过正则表达式形式应用到classpath中的，样例代码如下：

```bash
restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jar restart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar
```

> **注意**
> 
> 所有属性的键都必须是唯一的。只要你的属性是以`restart.include`或`restart.exclude`开头的，都需要这样。

> **小贴士**
> 
> 所有的从classpath类路径下的`META-INF/spring-devtools.properties`都会被加载。你可以将其打包进你的项目，或者项目使用的类库中。


### 已知的限制

在使用标准`ObjectInputStream`库反序列化的对象时，重启功能不能很好的工作。如果你需要反序列化数据，你可能需要使用Spring的`ConfigurableObjectInputStream`和`Thread.currentThread().getContextClassLoader()`。

遗憾的是，一些第三方反序列化库没有考虑到上下文加载器。如果你发现了这样的问题，你需要向原作者发送修复的请求。



































